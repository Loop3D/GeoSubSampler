# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoSubSampler
                                 A QGIS plugin
 Subsamples geological orientations, faults and polygons
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-28
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Ranee Joshi
        email                : raneejoshi@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import QgsProject, QgsMapLayerProxyModel, Qgis
from qgis.core import QgsVectorLayer, QgsProject
from qgis.PyQt.QtWidgets import QDockWidget
from qgis.core import QgsMessageLog, Qgis


# Qt5/Qt6 Compatibility Layer
try:
    # Try Qt6 style first
    _test = Qt.DockWidgetArea.RightDockWidgetArea
    # Qt6 detected
    QT6 = True

    # Qt6 style enums are already available
    RightDockWidgetArea = Qt.DockWidgetArea.RightDockWidgetArea


except AttributeError:
    # Qt5 detected
    QT6 = False

    # Qt5 style enums
    RightDockWidgetArea = Qt.RightDockWidgetArea


# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .GeoSubSampler_dockwidget import GeoSubSamplerDockWidget
import os.path
from .calcs.StructuralOrientationSubSampler import StructuralOrientationSubSampler
from .calcs.StructuralPolygonSubSampler import StructuralPolygonSubSampler
from .calcs.PolygonTriangulator import PolygonTriangulator
from .calcs.FaultLineMerger import FaultLineMerger
from .calcs.FaultLengths import FaultLengths
from .calcs.FaultsGraph import FaultsGraph
from .calcs.FaultStratOffset import FaultStratOffset
from .calcs.FaultClusterOrientation import FaultsOrientations
import geopandas as gpd
import os
import random
import time
import numpy as np


class GeoSubSampler:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "GeoSubSampler_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&GeoSubSampler")
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar("GeoSubSampler")
        self.toolbar.setObjectName("GeoSubSampler")

        # print "** INITIALIZING GeoSubSampler"

        self.pluginIsActive = False
        self.dockwidget = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("GeoSubSampler", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/GeoSubSampler/icon.png"
        self.add_action(
            icon_path,
            text=self.tr("GeoSubSampler"),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

    # --------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        # print "** CLOSING GeoSubSampler"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        # print "** UNLOAD GeoSubSampler"

        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&GeoSubSampler"), action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    # --------------------------------------------------------------------------

    # --------------------------------------------------------------------------
    def removeAllLayersByName(self, layerName):
        """
        Remove all layers with the given name
        """
        layers = QgsProject.instance().mapLayersByName(layerName)

        if layers:
            for layer in layers:
                QgsProject.instance().removeMapLayer(layer.id())
            # print(f"Removed {len(layers)} layer(s) named '{layerName}'")
            return len(layers)
        else:
            print(f"No layers found with name '{layerName}'")
            return 0

    def setUpPointSampler(self, checkFields=True):
        layerName = self.dockwidget.mMapLayerComboBox_points.currentText()
        dip_col = self.dockwidget.mFieldComboBox_dip.currentText()
        dip_dir_col = self.dockwidget.mFieldComboBox_dip_dir.currentText()

        if layerName == "":
            return False

        if os.path.exists(self.points_layer.source()):

            gdf = gpd.read_file(self.points_layer.source())

            if (dip_col == "" or dip_dir_col == "") and checkFields:
                self.iface.messageBar().pushMessage(
                    "Please define dip & dip dir/strike fields before continuing!",
                    level=Qgis.Warning,
                    duration=15,
                )
                return False
            elif dip_col == "" or dip_dir_col == "":
                dip_col = gdf.columns[1]
                dip_dir_col = gdf.columns[2]

            if self.dockwidget.checkBox_dip_dir.isChecked():
                dip_convention = "dip_direction"
            else:
                dip_convention = "strike"

            # Create an instance of StructuralOrientationSubSampler
            return StructuralOrientationSubSampler(
                gdf, dip_col, dip_dir_col, dip_convention
            )
        else:
            self.iface.messageBar().pushMessage(
                "Sorry, only layers saved to disk as a shapefile can be processed!",
                level=Qgis.Warning,
                duration=15,
            )
            return False

    def finalisePointSampler(self, gdf2, qgis_layer, name, param):
        layer_path = os.path.dirname(qgis_layer.source())
        new_path = (
            layer_path
            + "/"
            + qgis_layer.name()
            + "_"
            + name
            + "_"
            + str(param)
            + ".shp"
        )
        # print("new_path:", new_path)
        if os.path.exists(new_path):
            random_5_digit_integer = random.randint(10000, 99999)
            new_path = (
                layer_path
                + "/"
                + qgis_layer.name()
                + "_"
                + name
                + "_"
                + str(param)
                + "_"
                + str(random_5_digit_integer)
                + ".shp"
            )
        # print("new_path_2:", new_path)
        # Write GeoPandas back to file
        gdf2.to_file(new_path, driver="ESRI Shapefile")

        # reload as layer
        upscaled_layer = QgsVectorLayer(
            new_path, qgis_layer.name() + "_" + name + "_" + str(param), "ogr"
        )

        # Check if layer is valid
        if upscaled_layer.isValid():
            QgsProject.instance().addMapLayer(upscaled_layer)
        else:
            print("Failed to load layer", qgis_layer.name() + "_" + name)

        QgsProject.instance().addMapLayer(upscaled_layer)

    def decimation(self):
        # Create an instance of StructuralOrientationSubSampler
        pointSubsampler = self.setUpPointSampler()

        if pointSubsampler:
            n = int(self.dockwidget.lineEdit_rate.text())

            # Perform decimation subsampling
            gdf2 = pointSubsampler.decimation(n=n)

            # Write GeoPandas back to file and reload
            self.finalisePointSampler(gdf2, self.points_layer, "decimate", n)

    def stochastic(self):
        # Create an instance of StructuralOrientationSubSampler
        pointSubsampler = self.setUpPointSampler(False)

        if pointSubsampler:
            retain_percentage = float(self.dockwidget.mQgsDoubleSpinBox_percent.value())

            # Perform stochastic subsampling
            gdf2 = pointSubsampler.stochastic_subsampling(
                retain_percentage=retain_percentage,
                random_state=random.seed(int(time.time())),
            )

            # Write GeoPandas back to file and reload
            self.finalisePointSampler(
                gdf2, self.points_layer, "stochastic", retain_percentage
            )

    def gridCellAveraging(self):
        # Create an instance of StructuralOrientationSubSampler
        pointSubsampler = self.setUpPointSampler()

        if pointSubsampler:
            grid_size = float(self.dockwidget.lineEdit_grid_size.text())
            self.point_layer = self.dockwidget.mMapLayerComboBox_points.currentLayer()

            crs = self.point_layer.crs()
            if crs.isGeographic():
                grid_size = grid_size / 110000

            # Perform grid subsampling
            gdf2 = pointSubsampler.gridCellAveraging(grid_size=grid_size)

            # Write GeoPandas back to file and reload
            self.finalisePointSampler(
                gdf2, self.points_layer, "gridCellAveraging", grid_size
            )

    def kent(self):
        # Create an instance of StructuralOrientationSubSampler
        pointSubsampler = self.setUpPointSampler()

        if pointSubsampler:
            grid_size = float(self.dockwidget.lineEdit_grid_size_kent.text())
            self.point_layer = self.dockwidget.mMapLayerComboBox_points.currentLayer()

            crs = self.point_layer.crs()
            if crs.isGeographic():
                grid_size = grid_size / 110000

            # Perform grid subsampling
            gdf2 = pointSubsampler.spherical_statistics_kent(grid_size=grid_size)

            # Write GeoPandas back to file and reload
            self.finalisePointSampler(
                gdf2, self.points_layer, "grid_cell_kent", grid_size
            )

    def kentOutlier(self):
        # Create an instance of StructuralOrientationSubSampler
        pointSubsampler = self.setUpPointSampler()

        if pointSubsampler:
            grid_size = float(self.dockwidget.lineEdit_grid_size_kent_2.text())
            self.point_layer = self.dockwidget.mMapLayerComboBox_points.currentLayer()

            crs = self.point_layer.crs()
            if crs.isGeographic():
                grid_size = grid_size / 110000

            outlier_threshold = float(self.dockwidget.lineEdit_kent_threshold.text())

            # Perform grid subsampling
            gdf2 = pointSubsampler.outlier_removal(
                grid_size=grid_size, outlier_threshold=outlier_threshold
            )

            # Write GeoPandas back to file and reload
            self.finalisePointSampler(
                gdf2, self.points_layer, "grid_cell_kentOutlier", grid_size
            )

    def firstOrder(self):
        pass

    def minPolyArea(self):
        self.polygon_layer = (
            self.dockwidget.mMapLayerComboBox_maps_polygons.currentLayer()
        )
        if self.polygon_layer is not None:
            if os.path.exists(self.polygon_layer.source()):
                distance_threshold = float(
                    self.dockwidget.lineEdit_node_tolerance.text()
                )
                lithoname = self.dockwidget.mFieldComboBox_priority_5.currentText()
                strat1 = self.dockwidget.mFieldComboBox_priority_1.currentText()
                strat2 = self.dockwidget.mFieldComboBox_priority_2.currentText()
                strat3 = self.dockwidget.mFieldComboBox_priority_3.currentText()
                strat4 = self.dockwidget.mFieldComboBox_priority_4.currentText()
                dyke_codes = (
                    self.dockwidget.plainTextEdit_dyke_Codes.toPlainText()
                    .replace(" ", "")
                    .split(",")
                )
                dyke_field = self.dockwidget.mFieldComboBox_dyke.currentText()
                dyke_index = self.dockwidget.mFieldComboBox_dyke.currentIndex()
                incScale = self.dockwidget.mQgsDoubleSpinBox_upinc.value()

                if self.dockwidget.checkBox_series.isChecked():
                    minScale = float(self.dockwidget.mQgsDoubleSpinBox_upinc.value())
                    maxScale = float(self.dockwidget.lineEdit_polygon_area.text())
                else:
                    minScale = float(self.dockwidget.lineEdit_polygon_area.text())
                    maxScale = float(self.dockwidget.lineEdit_polygon_area.text())

                for upScale in np.arange(0.0, maxScale + 0.001, incScale):
                    min_area_threshold = ((upScale / 2) ** 2) * np.pi
                    parameter = str(upScale)
                    crs = self.polygon_layer.crs()
                    if crs.isGeographic():
                        min_area_threshold = min_area_threshold / (110000 * 110000)
                        distance_threshold = distance_threshold / 110000

                    layer_path = os.path.dirname(self.polygon_layer.source())
                    new_path = (
                        layer_path
                        + "/"
                        + self.polygon_layer.name()
                        + "_min_area_"
                        + parameter
                        + ".shp"
                    )
                    if os.path.exists(new_path):
                        random_5_digit_integer = random.randint(10000, 99999)
                        new_path = (
                            layer_path
                            + "/"
                            + self.polygon_layer.name()
                            + "_min_area_"
                            + parameter
                            + "_"
                            + str(random_5_digit_integer)
                            + ".shp"
                        )

                    # Convert QGIS layer to GeoPandas if first in series
                    if upScale == 0.0:
                        gdf = gpd.read_file(self.polygon_layer.source())

                    # Handle dykes special case
                    if dyke_index != 0:
                        triangulator = PolygonTriangulator(
                            gdf=gdf,
                            id_column=dyke_field,
                            min_area_threshold=min_area_threshold * 1000000.0,
                            distance_threshold=distance_threshold,
                            strat1=strat1,
                            strat2=strat2,
                            strat3=strat3,
                            strat4=strat4,
                            lithoname=lithoname,
                        )
                        gdf = triangulator.triangulate_polygons(target_ids=dyke_codes)

                    # Create an instance of StructuralOrientationSubSampler
                    polygonSubsampler = StructuralPolygonSubSampler(gdf)
                    # Modified parameter order: stratigraphic fields come before lithological field
                    output_gdf = polygonSubsampler.clean_small_polygons_and_holes_new(
                        gdf,
                        min_area_threshold=min_area_threshold * 1000000.0,
                        distance_threshold=distance_threshold,
                        strat1=strat1,
                        strat2=strat2,
                        strat3=strat3,
                        strat4=strat4,
                        lithoname=lithoname,
                    )
                    output_gdf.to_file(new_path, driver="ESRI Shapefile")

                    # reload as layer
                    upscaled_layer = QgsVectorLayer(
                        new_path,
                        self.polygon_layer.name() + "_min_area_" + parameter,
                        "ogr",
                    )

                    # Check if layer is valid
                    if upscaled_layer.isValid():
                        QgsProject.instance().addMapLayer(upscaled_layer)
                    else:
                        print(
                            "Failed to load layer",
                            self.polygon_layer.name() + "_min_area",
                        )

                    QgsProject.instance().addMapLayer(upscaled_layer)
            else:
                self.iface.messageBar().pushMessage(
                    "Sorry, only layers saved to disk as a shapefile can be processed!",
                    level=Qgis.Warning,
                    duration=15,
                )

    def mergeSegments(self):
        self.polyline_layer = (
            self.dockwidget.mMapLayerComboBox_fault_polylines.currentLayer()
        )
        if os.path.exists(self.polyline_layer.source()):
            distance_tolerance = float(self.dockwidget.lineEdit_merge_tolerance.text())
            angle_tolerance = float(self.dockwidget.lineEdit_merge_search_angle.text())
            min_join_angle = float(self.dockwidget.lineEdit_merge_join_angle.text())

            merger = FaultLineMerger(
                distance_tolerance=distance_tolerance,  # 10 map units
                angle_tolerance=angle_tolerance,  # 30 degrees for line parallelism
                min_join_angle=min_join_angle,  # Minimum 150° angle at join point (rejects angles < 150°)
            )

            layer_path = os.path.dirname(self.polyline_layer.source())
            new_path = layer_path + "/" + self.polyline_layer.name() + "_merged.shp"
            if os.path.exists(new_path):
                random_5_digit_integer = random.randint(10000, 99999)
                new_path = (
                    layer_path
                    + "/"
                    + self.polyline_layer.name()
                    + "_merged_"
                    + str(random_5_digit_integer)
                    + ".shp"
                )

            gdf = gpd.read_file(self.polyline_layer.source())
            output_gdf = merger.process_shapefile(gdf)
            output_gdf.to_file(new_path, driver="ESRI Shapefile")

            # reload as layer
            upscaled_layer = QgsVectorLayer(
                new_path,
                self.polyline_layer.name() + "_merged",
                "ogr",
            )

            # Check if layer is valid
            if upscaled_layer.isValid():
                QgsProject.instance().addMapLayer(upscaled_layer)
            else:
                print("Failed to load layer", self.polyline_layer.name() + "_merge")

        else:
            self.iface.messageBar().pushMessage(
                "Sorry, only layers saved to disk as a shapefile can be processed!",
                level=Qgis.Warning,
                duration=15,
            )

    def fault_Graph(self):
        self.polyline_layer = (
            self.dockwidget.mMapLayerComboBox_fault_polylines.currentLayer()
        )
        if os.path.exists(self.polyline_layer.source()):
            graph_obj = FaultsGraph()
            graph_obj.CalcFaultsGraph(self.polyline_layer.source())
            directory, filename = os.path.split(self.polyline_layer.source())
            new_path = (
                directory
                + "/simplified_full_"
                + str(filename).replace(".shp", "_edges.shp")
            )
            print("dir fn np", directory, filename, new_path)
            graph_layer = QgsVectorLayer(
                new_path, self.polyline_layer.name() + "_graph", "ogr"
            )

            # Check if layer is valid
            if graph_layer.isValid():
                QgsProject.instance().addMapLayer(graph_layer)
            else:
                print("Failed to load layer", self.polyline_layer + "_graph")

    def fault_strat_offset(self):
        self.polyline_layer = (
            self.dockwidget.mMapLayerComboBox_fault_polylines.currentLayer()
        )
        if os.path.exists(self.polyline_layer.source()) and os.path.exists(
            self.map_layer.source()
        ):

            strat_columns = []
            if self.dockwidget.mFieldComboBox_priority_1.currentText():
                strat_columns.append(
                    self.dockwidget.mFieldComboBox_priority_1.currentText()
                )
            if self.dockwidget.mFieldComboBox_priority_2.currentText():
                strat_columns.append(
                    self.dockwidget.mFieldComboBox_priority_2.currentText()
                )
            if self.dockwidget.mFieldComboBox_priority_3.currentText():
                strat_columns.append(
                    self.dockwidget.mFieldComboBox_priority_3.currentText()
                )
            if self.dockwidget.mFieldComboBox_priority_4.currentText():
                strat_columns.append(
                    self.dockwidget.mFieldComboBox_priority_4.currentText()
                )

            strat_offset_obj = FaultStratOffset()
            strat_offset_obj.CalcFaultStratOffset(
                self.polyline_layer.source(),
                self.map_layer.source(),
                self.polyline_layer.source().replace(".shp", "_stratOffset.shp"),
                strat_columns,
                offset_distance=50,
            )

            directory, filename = os.path.split(self.polyline_layer.source())
            new_path = (
                directory + "/" + str(filename).replace(".shp", "_stratOffset.shp")
            )
            print("dir fn np", directory, filename, new_path)
            graph_layer = QgsVectorLayer(
                new_path, self.polyline_layer.name() + "_stratOffset", "ogr"
            )

            # Check if layer is valid
            if graph_layer.isValid():
                QgsProject.instance().addMapLayer(graph_layer)
            else:
                print("Failed to load layer", self.polyline_layer + "_stratOffset")

    def fault_Lengths(self):
        self.polyline_layer = (
            self.dockwidget.mMapLayerComboBox_fault_polylines.currentLayer()
        )
        if os.path.exists(self.polyline_layer.source()):

            crs = self.polyline_layer.crs()
            if crs.isGeographic():
                crs_units = "degrees"
            else:
                crs_units = "meters"

            outPath = self.polyline_layer.source().replace(".shp", "_length.shp")
            filter_obj = FaultLengths()
            gdf = filter_obj.add_polyline_length(self.polyline_layer.source(), output_path=outPath, length_field='line_len', 
                        unit=crs_units, force_projection=None)

            # reload as layer
            upscaled_layer = QgsVectorLayer(
                outPath,
                self.polyline_layer.name() + "_Length",
                "ogr",
            )

            # Check if layer is valid
            if upscaled_layer.isValid():
                QgsProject.instance().addMapLayer(upscaled_layer)
            else:
                print("Failed to load layer", self.polyline_layer.name() + "_Length")

        else:
            self.iface.messageBar().pushMessage(
                "Sorry, only layers saved to disk as a shapefile can be processed!",
                level=Qgis.Warning,
                duration=15,
            )


    def fault_ClusterOrientations(self):
        print("fault_ClusterOrientations")
        print("polyline_layer:", self.dockwidget.mMapLayerComboBox_fault_polylines.currentText())
        self.polyline_layer = (
            self.dockwidget.mMapLayerComboBox_fault_polylines.currentLayer()
        )
        if os.path.exists(self.polyline_layer.source()):
            outPath = self.polyline_layer.source().replace(".shp", "_endpt_az.shp")
            filter_obj = FaultsOrientations()
            gdf = filter_obj.add_endpoint_azimuth(
            self.polyline_layer.source(), 
            outPath,
            azimuth_field='endpt_az'
            )

            best_n = filter_obj.example_manual_clusters(outPath, self.dockwidget.mMapLayerComboBox_fault_polylines.currentText(),azimuth_field='endpt_az')
            layer_path = os.path.dirname(self.polyline_layer.source())
            new_path = (
                layer_path
                + "/"
                + self.polyline_layer.name()
                + f"_fault_clusters_{best_n}.shp"
            )            
            
            upscaled_layer = QgsVectorLayer(
                new_path,
                self.polyline_layer.name() + f"_fault_clusters_{best_n}",
                "ogr",
            )

            # Check if layer is valid
            if upscaled_layer.isValid():
                QgsProject.instance().addMapLayer(upscaled_layer)
            else:
                print("Failed to load layer", self.polyline_layer.name() +  f"_fault_clusters_{best_n}")

    def updatePointsFields(self):
        """Update the fields in the points layer combo box when a new layer is selected."""
        layerName = self.dockwidget.mMapLayerComboBox_points.currentText()
        if layerName:
            self.points_layer = QgsProject.instance().mapLayersByName(layerName)[0]
            self.dockwidget.mFieldComboBox_dip.setLayer(self.points_layer)
            self.dockwidget.mFieldComboBox_dip_dir.setLayer(self.points_layer)

    def updateMapsFields(self):
        """Update the fields in the maps layer combo box when a new layer is selected."""
        layerName = self.dockwidget.mMapLayerComboBox_maps_polygons.currentText()
        if layerName:
            self.map_layer = QgsProject.instance().mapLayersByName(layerName)[0]
            self.dockwidget.mFieldComboBox_priority_1.setLayer(self.map_layer)
            self.dockwidget.mFieldComboBox_priority_2.setLayer(self.map_layer)
            self.dockwidget.mFieldComboBox_priority_3.setLayer(self.map_layer)
            self.dockwidget.mFieldComboBox_priority_4.setLayer(self.map_layer)
            self.dockwidget.mFieldComboBox_priority_5.setLayer(self.map_layer)
            self.dockwidget.mFieldComboBox_dyke.setLayer(self.map_layer)
            self.dockwidget.mFieldComboBox_priority_1.setAllowEmptyFieldName(True)
            self.dockwidget.mFieldComboBox_priority_2.setAllowEmptyFieldName(True)
            self.dockwidget.mFieldComboBox_priority_3.setAllowEmptyFieldName(True)
            self.dockwidget.mFieldComboBox_priority_4.setAllowEmptyFieldName(True)
            self.dockwidget.mFieldComboBox_priority_5.setAllowEmptyFieldName(True)
            self.dockwidget.mFieldComboBox_dyke.setAllowEmptyFieldName(True)
            self.dockwidget.mFieldComboBox_priority_1.setCurrentIndex(0)
            self.dockwidget.mFieldComboBox_priority_2.setCurrentIndex(0)
            self.dockwidget.mFieldComboBox_priority_3.setCurrentIndex(0)
            self.dockwidget.mFieldComboBox_priority_4.setCurrentIndex(0)
            self.dockwidget.mFieldComboBox_priority_5.setCurrentIndex(0)
            self.dockwidget.mFieldComboBox_dyke.setCurrentIndex(0)

    def defineTips(self):
        """
        Defines tooltips for various UI elements in the QGIS plugin.
        This method assigns descriptive tooltips to different widgets and controls
        in the plugin's user interface. These tooltips provide guidance and
        explanations for the functionality of each element, helping users
        understand their purpose and usage.
        """

        self.dockwidget.mMapLayerComboBox_points.setToolTip(
            "Points layer selected for processing"
        )
        self.dockwidget.mFieldComboBox_dip.setToolTip(
            "Field containing Dip information"
        )
        self.dockwidget.mFieldComboBox_dip_dir.setToolTip(
            "Field containing Dip Direction or Strike information"
        )
        self.dockwidget.checkBox_dip_dir.setToolTip(
            "Dip Direction used instead of Strike \nProbably not needed?"
        )
        """self.dockwidget.pushButton_decimation.setToolTip(
                "Simple point order decimation of points"
            )
            self.dockwidget.lineEdit_rate.setToolTip(
                "Keep every nth point, where n is the value entered here"
            )"""
        self.dockwidget.pushButton_stochastic.setToolTip(
            "Keep a randomly selected percentage of points "
        )
        self.dockwidget.mQgsDoubleSpinBox_percent.setToolTip(
            "Percentage of points to keep, between 0 and 100"
        )
        self.dockwidget.pushButton_gridCellAveraging.setToolTip(
            "Grid Cell Averaging of points"
        )
        self.dockwidget.lineEdit_grid_size.setToolTip(
            "Grid size in layer units for cell averaging"
        )
        self.dockwidget.pushButton_kent.setToolTip(
            "Grid Cell Averaging of points using Kent statistics"
        )
        self.dockwidget.lineEdit_grid_size_kent.setToolTip(
            "Grid size in layer units for cell averaging using Kent statistics"
        )
        self.dockwidget.pushButton_kentOutlier.setToolTip(
            "Grid size in layer units for cell averaging using Kent statistics removing biggest outlier"
        )
        self.dockwidget.lineEdit_grid_size_kent_2.setToolTip(
            "Threshold of points to remove ???"
        )

        self.dockwidget.pushButton_1o_sampling.setToolTip(
            "First order retewntion of points based on distance and angle to contacts"
        )
        self.dockwidget.lineEdit_1o_distance.setToolTip(
            "Distance buffer for first order retention of points"
        )
        self.dockwidget.lineEdit_1o_angle.setToolTip(
            "Angle tolerance for first order retention of points"
        )
        self.dockwidget.mMapLayerComboBox_maps_polygons.setToolTip(
            "Layer map polygons selected for processing"
        )
        self.dockwidget.lineEdit_node_tolerance.setToolTip(
            "Tolerance for node snapping in layer units"
        )
        self.dockwidget.mFieldComboBox_priority_1.setToolTip(
            "Field selected for 1st priority of polygon merging"
        )
        self.dockwidget.mFieldComboBox_priority_2.setToolTip(
            "Field selected for 2nd priority of polygon merging"
        )
        self.dockwidget.mFieldComboBox_priority_3.setToolTip(
            "Field selected for 3rd priority of polygon merging"
        )
        self.dockwidget.mFieldComboBox_priority_4.setToolTip(
            "Field selected for 4th priority of polygon merging"
        )
        self.dockwidget.mFieldComboBox_priority_5.setToolTip(
            "Field selected for 5th priority of polygon merging"
        )
        self.dockwidget.mFieldComboBox_dyke.setToolTip("Field selected for dyke codes")
        self.dockwidget.plainTextEdit_dyke_Codes.setToolTip(
            "Comma separated list of dyke codes for special handling"
        )
        self.dockwidget.lineEdit_polygon_area.setToolTip(
            "Minimum threshold diameter of polygons to be retained (in km)"
        )
        self.dockwidget.checkBox_series.setToolTip(
            "Calculate full series of rescaling maps between increment and threshold"
        )
        self.dockwidget.mQgsDoubleSpinBox_upinc.setToolTip(
            "Increment for arithmetic series of maps"
        )
        self.dockwidget.pushButton_minPolyArea.setToolTip("Rescale map polygons")
        self.dockwidget.mMapLayerComboBox_maps_polylines.setToolTip(
            "Fault polyline layer selected for processing"
        )
        self.dockwidget.mMapLayerComboBox_fault_polylines.setToolTip(
            "Fault polyline layer selected for processing"
        )
        self.dockwidget.pushButton_merge_segments.setToolTip(
            "Merge connected polylines\nWARNING: VERY SLOW FOR LARGE DATASETS (>1s per object)"
        )
        self.dockwidget.lineEdit_merge_tolerance.setToolTip(
            "Minimum distance between end points"
        )
        self.dockwidget.lineEdit_merge_search_angle.setToolTip(
            "Minimum angle mismatch between end segments"
        )
        self.dockwidget.lineEdit_merge_join_angle.setToolTip(
            "Maximum angle for newly-formed angle defined by end segments"
        )
        self.dockwidget.pushButton_fault_length.setToolTip("Add faults length\n"
            "Does not filter data, just adds length attribute")
        
        self.dockwidget.pushButton_fault_graph.setToolTip(
            "Add graph data to faults\n"
            "Does not filter data, just adds graph attributes"
        )
        self.dockwidget.pushButton_fault_orientation_clusters.setToolTip(
            "Add suite of orientation cluster data to faults (2-7 clusters)\n"
            "Does not filter data, just adds cluster attributes"
        )
        self.dockwidget.pushButton_fault_strat_offset.setToolTip(
            "Add stratigraphic offset data to faults\n"
            "Requires both fault and map polygon layers\n"
            "as well as Geology Map Priority Codes to be defined\n"
            "Does not filter data, just adds Strat Offset attributes"
        )


    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            # print ("** STARTING GeoSubSampler")

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = GeoSubSamplerDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(RightDockWidgetArea, self.dockwidget)
            # Find existing dock widgets in the right area
            right_docks = [
                d
                for d in self.iface.mainWindow().findChildren(QDockWidget)
                if self.iface.mainWindow().dockWidgetArea(d) == RightDockWidgetArea
            ]
            # If there are other dock widgets, tab this one with the first one found
            if right_docks:
                for dock in right_docks:
                    if dock != self.dockwidget:
                        self.iface.mainWindow().tabifyDockWidget(dock, self.dockwidget)
                        # Optionally, bring your plugin tab to the front
                        self.dockwidget.raise_()
                        break
            # Raise the docked widget above others
            self.defineTips()
            self.dockwidget.show()
            self.dockwidget.mMapLayerComboBox_points.setFilters(
                QgsMapLayerProxyModel.PointLayer
            )

            self.dockwidget.mMapLayerComboBox_maps_polygons.setFilters(
                QgsMapLayerProxyModel.PolygonLayer
            )
            self.dockwidget.mMapLayerComboBox_maps_polylines.setFilters(
                QgsMapLayerProxyModel.LineLayer
            )
            self.dockwidget.mMapLayerComboBox_fault_polylines.setFilters(
                QgsMapLayerProxyModel.LineLayer
            )
            layerName = self.dockwidget.mMapLayerComboBox_points.currentText()
            if layerName:
                self.points_layer = QgsProject.instance().mapLayersByName(layerName)[0]
                self.dockwidget.mFieldComboBox_dip.setLayer(self.points_layer)
                self.dockwidget.mFieldComboBox_dip_dir.setLayer(self.points_layer)

            layerName = self.dockwidget.mMapLayerComboBox_maps_polygons.currentText()
            if layerName:
                self.updateMapsFields()

            self.dockwidget.mMapLayerComboBox_points.layerChanged.connect(
                self.updatePointsFields
            )
            self.dockwidget.mMapLayerComboBox_maps_polygons.layerChanged.connect(
                self.updateMapsFields
            )

            # self.dockwidget.pushButton_decimation.clicked.connect(self.decimation)
            self.dockwidget.pushButton_stochastic.clicked.connect(self.stochastic)
            self.dockwidget.pushButton_gridCellAveraging.clicked.connect(
                self.gridCellAveraging
            )
            self.dockwidget.pushButton_kent.clicked.connect(self.kent)
            self.dockwidget.pushButton_kentOutlier.clicked.connect(self.kentOutlier)
            self.dockwidget.pushButton_1o_sampling.clicked.connect(self.firstOrder)

            self.dockwidget.pushButton_minPolyArea.clicked.connect(self.minPolyArea)

            self.dockwidget.pushButton_merge_segments.clicked.connect(
                self.mergeSegments
            )
            self.dockwidget.pushButton_fault_length.clicked.connect(self.fault_Lengths)
            self.dockwidget.pushButton_fault_graph.clicked.connect(self.fault_Graph)
            self.dockwidget.pushButton_fault_strat_offset.clicked.connect(
                self.fault_strat_offset
            )
            self.dockwidget.pushButton_fault_orientation_clusters.clicked.connect(
                self.fault_ClusterOrientations
            )
            self.dockwidget.mFieldComboBox_dip.setAllowEmptyFieldName(True)
            self.dockwidget.mFieldComboBox_dip.setCurrentIndex(0)
            self.dockwidget.mFieldComboBox_dip_dir.setAllowEmptyFieldName(True)
            self.dockwidget.mFieldComboBox_dip_dir.setCurrentIndex(0)
